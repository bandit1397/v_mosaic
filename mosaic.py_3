import cv2
import sys
import os

# 설정
video_path = "input.mp4"
output_path = "output_mosaic.mp4"

def load_frames(path):
    cap = cv2.VideoCapture(path)
    frames = []
    if not cap.isOpened():
        return None
    while True:
        ret, f = cap.read()
        if not ret: break
        frames.append(f)
    fps = cap.get(cv2.CAP_PROP_FPS)
    cap.release()
    return frames, fps

# 1. 원본과 기존 작업물 로드
print("영상을 로딩 중...")
origin_frames, fps = load_frames(video_path)
if fps <= 0: fps = 30

# 만약 이전에 작업하던 output 파일이 있다면 그것을 불러오고, 없으면 원본 복사
if os.path.exists(output_path):
    print(f"기존 작업물({output_path})을 불러와 이어 붙입니다.")
    processed_frames, _ = load_frames(output_path)
    # 프레임 수가 맞지 않을 경우를 대비해 보정
    if not processed_frames or len(processed_frames) != len(origin_frames):
        processed_frames = [f.copy() for f in origin_frames]
else:
    print("새 작업을 시작합니다.")
    processed_frames = [f.copy() for f in origin_frames]

total_frames = len(origin_frames)
h, w, _ = origin_frames[0].shape

# 상태 변수
current_idx = 0
paused = True
trackers = []
window_name = "Continuous Mosaic Editor"

def on_trackbar(val):
    global current_idx
    current_idx = val

def mosaic_strong(img, roi_rect):
    x, y, rw, rh = map(int, roi_rect)
    x, y = max(0, x), max(0, y)
    rw, rh = min(rw, img.shape[1]-x), min(rh, img.shape[0]-y)
    if rw <= 0 or rh <= 0: return img
    roi_zone = img[y:y+rh, x:x+rw]
    level = 25 # 모자이크 강도
    small = cv2.resize(roi_zone, (max(1, rw//level), max(1, rh//level)))
    img[y:y+rh, x:x+rw] = cv2.resize(small, (rw, rh), interpolation=cv2.INTER_NEAREST)
    return img

cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
cv2.createTrackbar("Timeline", window_name, 0, total_frames - 1, on_trackbar)

print("\n" + "="*50)
print("연속 작업 모드 가이드")
print("1. [Timeline] 슬라이더를 움직여 모자이크가 빠진 곳을 찾으세요.")
print("2. [S] 키로 대상을 지정하고 [Space]로 재생하여 채워넣으세요.")
print("3. [ESC]를 누르면 현재까지의 모든 내용이 output_mosaic.mp4로 업데이트됩니다.")
print("="*50)

while True:
    display_frame = processed_frames[current_idx].copy()
    
    # 재생 및 트래킹 (편집)
    if not paused:
        if trackers:
            for t in trackers:
                ok, roi = t.update(origin_frames[current_idx])
                if ok:
                    # 기존 작업된 화면(processed_frames) 위에 추가로 덧칠함
                    processed_frames[current_idx] = mosaic_strong(processed_frames[current_idx], roi)
            
            display_frame = processed_frames[current_idx]
        
        if current_idx < total_frames - 1:
            current_idx += 1
        else:
            paused = True

    # 안내 문구
    cv2.putText(display_frame, f"Frame: {current_idx}/{total_frames-1}", (20, 40), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
    if not paused:
        cv2.putText(display_frame, "RECORDING...", (20, 70), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

    cv2.imshow(window_name, display_frame)
    cv2.setTrackbarPos("Timeline", window_name, current_idx)

    key = cv2.waitKey(20) & 0xFF
    if key == 27: break
    elif key == ord(' '): paused = not paused
    elif key == ord('s'):
        # 현재 화면(편집본)을 보면서 대상 지정
        new_rois = cv2.selectROIs("Select Target", processed_frames[current_idx], False, False)
        if len(new_rois) > 0:
            trackers = []
            for r in new_rois:
                tr = cv2.TrackerCSRT_create()
                tr.init(origin_frames[current_idx], tuple(r))
                trackers.append(tr)
        cv2.destroyWindow("Select Target")

# 4. 저장 (기존 파일을 덮어쓰며 업데이트)
print("\n작업 내용을 저장(업데이트) 중입니다...")
out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))
for f in processed_frames:
    out.write(f)
out.release()

cv2.destroyAllWindows()
print(f"완료! {output_path} 파일이 업데이트되었습니다.")
